# MIKIR-OS 全面改訂ロードマップ

**方針**: 土台はアセンブリ（IPL + ローダ）、その上は **C でカーネル** を書く。

---

## 現在の構成（C 導入済み）

| レイヤ | ファイル | 言語 | 役割 |
|--------|----------|------|------|
| IPL | ipl.nas | asm | ブートセクタ。セクタ2以降を 0x8000 に読み、ローダへジャンプ。 |
| ローダ | loader.nas | asm | A20/GDT/プロテクトモード移行 → **kernel_main()** を呼ぶ。 |
| カーネル | kernel/kernel.c | **C** | 32bit で VGA に表示。ここからシェル・ドライバを拡張。 |

ビルド: `make`（nasm, gcc -m32, ld, objcopy が必要）

---

## 改訂の段階（フェーズ）

### Phase 1: ブートと2次ローダ（完了）

- IPL + ローダ（asm）、プロテクトモード移行、**C kernel_main()** で VGA 表示。

### Phase 2: シェルもどき（C で実装）

| 目標 | 内容 |
|------|------|
| コマンドループ | kernel.c 内で 1 行入力 → 解釈 → 実行のループ。 |
| 内部コマンド | `help`, `ver`, `echo`, `clear` など。 |
| 文字列処理 | 入力バッファ、トークン分割を C で実装。 |

**成果物**: 起動後、プロンプトでコマンドを打てる「使える」コンソール。

### Phase 3: 割り込みとメモリ（C + asm の土台）

| 目標 | 内容 |
|------|------|
| IDT / PIC | 割り込み設定（asm で初期化、C でハンドラ登録）。 |
| タイマ・キーボード | 割り込み駆動の入力・時刻。 |
| 簡易メモリマップ | 使用可能領域の把握。 |

**成果物**: 割り込み駆動のシェル。

---

### Phase 4: 割り込みとタイマ

| 目標 | 内容 |
|------|------|
| IDT 設定 | 例外・割り込みベクタ。 |
| PIC 設定 | マスター/スレーブ。 |
| タイマ割り込み | PIT で周期処理（スリープや時刻の基礎）。 |
| キーボード割り込み | IRQ1 でキー入力。 |

**成果物**: 割り込み駆動の入力・タイマ。

---

### Phase 5: ファイルシステムとアプリ

| 目標 | 内容 |
|------|------|
| FAT12 読み込み | ディスク上のファイル名検索・読み込み。 |
| 簡単な実行 | 指定セクタを読み込んで実行（バイナリロード）。 |
| コマンド拡張 | `dir`, `type`, `run` など。 |

**成果物**: ディスクから「プログラム」を選んで実行できる状態。

---

### Phase 6 以降（必要に応じて）

- メモリ管理（ページング、簡易 malloc）
- マルチタスク（TSS とコンテキスト切り替え）
- シンプルなウィンドウ/UI（VGA グラフィック）
- ネットワーク（NIC ドライバ + 簡易スタック）

---

## 技術スタック案

| 項目 | 案 |
|------|-----|
| アセンブラ | NASM（現状のまま）。 |
| 2次ローダ以降 | アセンブリ → 必要に応じて C（GCC, -ffreestanding）を併用。 |
| ビルド | Makefile で `mikiros.img` を生成。 |
| 動作確認 | QEMU: `qemu-system-i386 -fda mikiros.img`。 |

---

## 次の一歩（Phase 1 の具体）

1. **mikiros.nas を分割**
   - `ipl.nas` … ブートセクタのみ（BPB + セクタ2以降を読む処理 + 0x55 0xaa）。
   - `loader.nas` … 2次ローダ（メッセージ表示 + INT 0x16 でキー待ち）。
2. **Makefile 追加**
   - `nasm ipl.nas -o ipl.bin`、`nasm loader.nas -o loader.bin`。
   - セクタ1に loader、残りは FAT 等で 1.44MB イメージを組み立て。
3. **QEMU で起動確認**
   - 起動 → メッセージ → キー入力で反応することを確認。

このロードマップに沿って、Phase 1 から順に実装すれば、**「使えるOS」として動くコンソール**まで確実に持っていけます。必要なら Phase 1 の NAS ソース分割と Makefile の具体的なコード案も書けます。
